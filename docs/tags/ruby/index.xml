<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ruby on rono23</title><link>https://rono23.com/tags/ruby/</link><description>Recent content in Ruby on rono23</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 15 Jan 2021 00:00:00 +0900</lastBuildDate><atom:link href="https://rono23.com/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>PKCEのcode_challenge生成</title><link>https://rono23.com/posts/2021-01-15/</link><pubDate>Fri, 15 Jan 2021 00:00:00 +0900</pubDate><guid>https://rono23.com/posts/2021-01-15/</guid><description>code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM https://tools.ietf.org/html/rfc7636
Swift
import CryptoKit let codeVerifier = &amp;#34;dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk&amp;#34; let data = Data(codeVerifier.utf8) let hash = SHA256.hash(data: data) let codeChallenge = Data(hash).base64EncodedString() .replacingOccurrences(of: &amp;#34;=&amp;#34;, with: &amp;#34;&amp;#34;) .replacingOccurrences(of: &amp;#34;+&amp;#34;, with: &amp;#34;-&amp;#34;) .replacingOccurrences(of: &amp;#34;/&amp;#34;, with: &amp;#34;_&amp;#34;) Ruby
require &amp;#39;base64&amp;#39; require &amp;#39;digest&amp;#39; code_verifier = &amp;#34;dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk&amp;#34; code_challenge = Base64.urlsafe_encode64(Digest::SHA256.digest(code_verifier), padding: false) 最初、ハッシュ値を文字列で扱って少しハマったけど CommonCrypto を使わずにできてよかった 🎉</description></item><item><title>Appleでサインインのアクセストークンとリフレッシュトークンの取得</title><link>https://rono23.com/posts/2020-02-19/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0900</pubDate><guid>https://rono23.com/posts/2020-02-19/</guid><description>Appleでサインインのトークン検証の続き。
セットアップ # Gemfile gem &amp;#34;jwt&amp;#34; # クライアントから送られてきたパラメータ code = &amp;#34;authorizationCode&amp;#34; # アプリのID（decoded_token[:aud]） client_id = &amp;#34;com.example.app&amp;#34; # https://developer.apple.com/account/#/membership team_id = &amp;#34;xxx&amp;#34; # https://developer.apple.com/account/resources/authkeys/list key_id = &amp;#34;xxx&amp;#34; key_file = File.read(Rails.root.join(&amp;#34;AuthKey_xxx.p8&amp;#34;)) key = OpenSSL::PKey::EC.new(key_file) access_token/refresh_token の取得 headers = { kid: key_id, alg: &amp;#34;ES256&amp;#34; } claims = { iss: team_id, sub: client_id, iat: Time.now.to_i, exp: Time.now.to_i + 1.day.to_i * 180, aud: &amp;#34;https://appleid.apple.com&amp;#34; } client_secret = JWT.encode claims, key, &amp;#34;ES256&amp;#34;, headers params = { client_id: client_id, client_secret: client_secret, code: code, grant_type: &amp;#34;authorization_code&amp;#34; } response = Net::HTTP.</description></item><item><title>Appleでサインインのトークン検証</title><link>https://rono23.com/posts/2020-02-12/</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0900</pubDate><guid>https://rono23.com/posts/2020-02-12/</guid><description>セットアップ # Gemfile gem &amp;#34;jwt&amp;#34; # クライアントから送られてきたパラメータ token = &amp;#34;identityToken&amp;#34; code = &amp;#34;authorizationCode&amp;#34; 署名検証 url = &amp;#34;https://appleid.apple.com/auth/keys&amp;#34; jwks = JSON.parse(open(url).read, symbolize_names: true) algorithms = jwks[:keys].map { |key| key[:alg] } # or tokenのHeaderの:alg decoded_token = JWT.decode(token, nil, true, algorithms: algorithms, jwks: jwks).first.with_indifferent_access # 1つのJWKだけ検証したいとき jwk = jwks[:keys].first public_key = JWT::JWK.import(jwk).keypair.public_key # or `JWT::JWK::RSA.import(jwk).public_key` JWT.decode(token, public_key, true, algorithm: &amp;#34;RS256&amp;#34;) # 期限は10分なので注意 JWT.decode(...) #=&amp;gt; JWT::ExpiredSignature: Signature has expired authorizationCodeの検証 # https://openid.net/specs/openid-connect-core-1_0.html#CodeValidation digest = Digest::SHA256.</description></item></channel></rss>